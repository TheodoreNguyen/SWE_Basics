Notes on Google Interview Prep Guide for SWE, as well as other documents

https://github.com/jwasham/coding-interview-university
https://leetcode.com/explore/
https://medium.com/@ratulsaha/preparing-for-programming-interview-as-a-phd-student-with-python-5f8af8b40d5f

general:
- explain how you think. clarify the assumptions you make
- solicit requirements & ask Q's to clarify requirements
- improve solution - start with brute force and improve and why. talk out loud
- whiteboard code no compiler

KNOW YOUR RESUME.

INTERVIEW 
- CLARIFY: solicit requirements from open ended question 
- EXPLAIN: explain solution in algorithm 
- PLAN: don't start writing code until you've planned what you're going to write.
- CODE: write code (brute force) -> improve original solution/optimize: edge/corner cases
- TEST: add test cases

programming + algorithms interviews
- CODE: grab one language - OOP design, APIs, TESTING CODE, testing corner/edge cases, error checking
- ALGO: complexity, sorting, search, divide/conquer, greedy, recursion, memoization/dynamic, data structure-algos
        - complex algos like Dijkstra & A*
        - big O complexity
        - popular np-complete problems - knapsack, traveling salesman. What is P vs NP-complete vs NP
- DATA structures: arrays, LL, stack, queue, hash-set/map/table (and diffs), dict, heaps VS priority queue,
    (binary) trees/trie (and all complex related stuff like traversal, construction, relinking, types, etc), graphs 
        - all algorithms for each as well, as well as their complexities
- SORT: ALL sorting algorithms - best, worst, average case space/time efficiencies and when ea occur for ea algo
        - ideally know details for at least 1-2 O(N LOG N) sorting algorithms
- SEARCH: BFS, DFS, binary search, substring search???, combinatorical search over solution spaces, etc
- MATH: discrete math - counting, probability, combinatorics, n choose k
- GRAPHS: propeprties - distance, search, connectivity, cycles. 
        - three ways represent a graph - objects + ptrs, (adjacency?) matrix, adjacency list + pros/cons of each
        - path finding & basic graph traversals like BFS and DPS + complexity + pros/cons + implementation
- RECURSION
- LOW LEVEL BIT MANIPULATION
- OPERATING SYSTEMS - see below
- SYSTEM DESIGN - see below - may be optional.

Operating systems - threads vs processes (& resources need by ea), concurrency issues, locks,
mutexes, semaphores, monitors, deadlock, livelock, context switching (done by OS/hardware),
scheduling, resource allocation 'fundamentals of modern concurrency'

system design - "build (company X)" (potentially only needed for ppl with more experience)
    - sets, interfaces, class hierarchies, distributed systems
    - design under constraints; simplicity, limitations, robustness and tradeoffs
    - internet: routers, domain name servers, load balancers, firewalls, search
graphs, run-time complexity of graphs, distributed hash table system,
resource estimation with real systems, big product design picture, translation of an abstract
problem to a system, API discussions, binary trees, cache, mapreduce, for loop problems,
index, reverse link-list, compilers, memory cache, networks


(more on testing code:)
    testing aptitude for less than 3 years exp unit tests interesting test cases
        integration, security load and performances

BOOKS:
- cracking the coding interview
- programming interviews exposed
- programming pearls
- intro to algorithms (CLRS)

INTERVIEW PREP:
- how google hires
- interviewing at google
- candidate coaching session

GOOGLE PUBLICATIONS:
- google file system
- bigtable
- mapreduce
- google spanner
- google chubby
- THERES MORE. LOOK IT UP.

XXXXXXXXXXXXXXXXSOFT STUFFXXXXXXXXXXXX

ABOUT GOOGLE:
- google company
- google story
- life at google
- google developers
- google open source
- style guide




-----------------------------video1------------------------------------
How to: Prepare for a Google Engineering Interview
https://www.youtube.com/watch?v=ko-KkSmp-Lk
----------------------------------------------------------
- prove resume
data structures and algorithms and complexity theory
whiteboard coding
system design   
oop
- problem slving skills w.r.t. type of question
coding speed finish problem
design make a good design
analysis question make sure u just analyze everything 
- prep: code. apis/oop/test/corneredge/algorithms/complexity/dijkstra/A*/
    testing aptitude for less than 3 years exp unit tests interesting test cases
        integration, security load and performances
    -NP complete problems - knapsack, traveling salesman
        WHAT IS NP WHAT IS NP-COMPLETE
trees and traversals and all usual data structures
math probability combinatorics n choose k
recursion - iteratives to recursion
OS - processe, threads, concurrency, semaphures, mutexes, locks. resource allocation. context switching. scheduling
system design. more than 5 years need to know this. 
    feature sets, interfaces, class hierarchies, distributed, system under contraints. 
    how does internet work - routers, domain names, load balancers, firewalls, search

EXPLAIN (everyuthing u do just say it) and CLARIFY (requirements solicitation)


-------------------------------video2---------------------------
How to: Work at Google â€” Example Coding/Engineering Interview
https://www.youtube.com/watch?v=XKu_SEDAykw
--------------------------------------------------------------
given a collection of numbers, find a matching pair that is equal to a sum given 
[1, 2, 3, 9]
sum = 8
[1, 2, 4, 4] 
sum = 8


CLARIFY: there is no array in the first array that adds up to 8, but there is one in the second
- how are the numbers given : in an array and ORDERED!
- can i repeat the same element in the same index? : no
- are these values of type integer?
- can negatives occur? : yeah.

SOLUTIONS: start with simplest first (pretty much what we have below). Quadratic and slow. O(N^2)

def first_sum_pair_primitive(collection, sum):
    #if our collection is only length 1 or 0, then there cannot be a pair whose sum is equal to sum
    if len(collection) < 2:
        return None
    #iterate through each unique pair of entries (aka don't check a pair with itself, doesnt count)
    i = 0
    while(i != len(collection)):
        j = i + 1
        while(j != len(collection)):
            if (collection[i] + collection[j]) == sum:
                return (collection[i], collection[j])
            j += 1
        i += 1
    return None
                
UTILIZE ORDERED ARRAY - BINARY SEARCH O(N LOG N)
def binary_search_mod(collection, val):
    L = 0
    H = len(collection) - 1
    while(L <= H):
        M = int((L + H)/2)
        if collection[M] > val:
            H = M - 1
        elif collection[M] < val:
            L = M + 1
        elif collection[M] == val:
            return M
    return None
        
def first_sum_pair_bs(collection, sum):
    index1 = 0
    while index1 != len(collection):
        diff = sum - collection[index1]
        index2 = binary_search_mod(collection[index1+1:], diff)
        if index2 != None:
            return (collection[index1], collection[index1 + index2])
        index1 += 1

    return None


REPLACE UNIDIRECTIONAL BINARY SEARCH WITH STARTING WITH A PAIR OF NUMBERS AND WORKING YOUR WAY INWARD. O(N)
def first_sum_pair_bidirectional(collection, sum):
    L = 0
    H = len(collection) - 1
    while(L < H):
        item1 = collection[L]
        item2 = collection[H]
        subsum = item1 + item2
        if subsum == sum:
            return item1, item2
        #its too big.
        elif subsum > sum:
            H -= 1
        #its too small
        elif subsum < sum:
            L += 1
    return None
    
Choose a programming language (already done)
 
CLARIFY (continued): 
    - do i want to return the pair, the pair indices, or True/False
        - if you wanted to return the pair, how would it be a problem if there was no pair
            - would probably return a struct containing a boolean and the pair
    
potential return type:
 
class Node:
    def __init__(self, boolean, item1, item2):
        self.boolean = boolean
        self.pair = item1, item2
        
        
My His C++ solution (before he does it):

bool hasPairWithSum(const vector<int>& data, int Sum)
{
    int low = 0
    int high = data.size() - 1
    //the condition also fixes case where arr is empty or has 1 value
    while(low < high)
    {
        item1 = data[low]
        item2 = data[high]
        subsum = item1 + item2
        if(subsum == Sum)
            return true
        else if(subsum > sum):
            high--
        else if(subsum < sum):
            low++
    }
    return false
}
 
- SACRIFICING SPACE COMPLEXITY FOR TIME COMPLEXITY
wrench thrown in - list no longer sorted
- quick solution using same solution - just sort first in N log N and then apply method in O(N) - still an O(N LOG N) complexity
- too slow.

def first_sum_pair_unsorted(collection, sum):
    complement_set = set()
    '''Dict = {}'''
    for item in collection:
        complement = sum - item
        #if this item satisfies a previous items complement
        if item in complement_set:
            return True
            '''return item, Dict[item] #for when you want the values/indices'''
        #add this items complement to the set, so later items can be checked to see if it that complement
        else:
            complement_set.add(complement)
            '''Dict[complement] = item'''
    
    return False
        
Test your code with the given examples. Make more examples to adequately find all edge and corner cases 
- mention potential underflow and overflow for brownie points (nobody gives a crap though)

- if the input was very large... what would you change?
    does it still fit in memory? : probably not
    are the range of the values limited in some way? : maybe?
        the set of the collection fits in memory, even though the collection itself doesnt
            - process collection in chunks
                - ?cooler to do it in parallel. each thread processes the set of complements. we just merge them. want to make sure we dont lookfor thing we put in
                as long as each computer checking in right order when we merge them, 
                
RECAP: clarify. think out loud. think through stuff before writing stuff. test in real time. edge cases
    
